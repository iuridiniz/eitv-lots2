/* Generated by dbus-binding-tool; do not edit! */

#include <glib.h>
#include <dbus/dbus-glib.h>

G_BEGIN_DECLS

#ifndef _DBUS_GLIB_ASYNC_DATA_FREE
#define _DBUS_GLIB_ASYNC_DATA_FREE
static
#ifdef G_HAVE_INLINE
inline
#endif
void
_dbus_glib_async_data_free (gpointer stuff)
{
	g_slice_free (DBusGAsyncData, stuff);
}
#endif

#ifndef DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_player
#define DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_player

static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_play_with_pids (DBusGProxy *proxy, const guint IN_video_pid, const guint IN_audio_pid, const guint IN_pcr_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "play_with_pids", error, G_TYPE_UINT, IN_video_pid, G_TYPE_UINT, IN_audio_pid, G_TYPE_UINT, IN_pcr_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_play_with_pids_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_play_with_pids_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_play_with_pids_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_play_with_pids_async (DBusGProxy *proxy, const guint IN_video_pid, const guint IN_audio_pid, const guint IN_pcr_pid, com_eitv_lots_player_play_with_pids_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "play_with_pids", com_eitv_lots_player_play_with_pids_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_video_pid, G_TYPE_UINT, IN_audio_pid, G_TYPE_UINT, IN_pcr_pid, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_play (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "play", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_play_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_play_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_play_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_play_async (DBusGProxy *proxy, com_eitv_lots_player_play_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "play", com_eitv_lots_player_play_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_stop (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "stop", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_stop_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_stop_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_stop_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_stop_async (DBusGProxy *proxy, com_eitv_lots_player_stop_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "stop", com_eitv_lots_player_stop_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_raise_to_top (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "raise_to_top", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_raise_to_top_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_raise_to_top_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_raise_to_top_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_raise_to_top_async (DBusGProxy *proxy, com_eitv_lots_player_raise_to_top_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "raise_to_top", com_eitv_lots_player_raise_to_top_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_lower_to_bottom (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "lower_to_bottom", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_lower_to_bottom_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_lower_to_bottom_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_lower_to_bottom_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_lower_to_bottom_async (DBusGProxy *proxy, com_eitv_lots_player_lower_to_bottom_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "lower_to_bottom", com_eitv_lots_player_lower_to_bottom_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_is_playing (DBusGProxy *proxy, gboolean* OUT_is_playing, GError **error)

{
  return dbus_g_proxy_call (proxy, "is_playing", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, OUT_is_playing, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_is_playing_reply) (DBusGProxy *proxy, gboolean OUT_is_playing, GError *error, gpointer userdata);

static void
com_eitv_lots_player_is_playing_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  gboolean OUT_is_playing;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_BOOLEAN, &OUT_is_playing, G_TYPE_INVALID);
  (*(com_eitv_lots_player_is_playing_reply)data->cb) (proxy, OUT_is_playing, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_is_playing_async (DBusGProxy *proxy, com_eitv_lots_player_is_playing_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "is_playing", com_eitv_lots_player_is_playing_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_set_size (DBusGProxy *proxy, const guint IN_width, const guint IN_height, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_size", error, G_TYPE_UINT, IN_width, G_TYPE_UINT, IN_height, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_set_size_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_set_size_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_set_size_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_set_size_async (DBusGProxy *proxy, const guint IN_width, const guint IN_height, com_eitv_lots_player_set_size_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_size", com_eitv_lots_player_set_size_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_width, G_TYPE_UINT, IN_height, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_size (DBusGProxy *proxy, guint* OUT_width, guint* OUT_height, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_size", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_width, G_TYPE_UINT, OUT_height, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_size_reply) (DBusGProxy *proxy, guint OUT_width, guint OUT_height, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_size_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_width;
  guint OUT_height;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_width, G_TYPE_UINT, &OUT_height, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_size_reply)data->cb) (proxy, OUT_width, OUT_height, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_size_async (DBusGProxy *proxy, com_eitv_lots_player_get_size_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_size", com_eitv_lots_player_get_size_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_max_size (DBusGProxy *proxy, guint* OUT_max_width, guint* OUT_max_height, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_max_size", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_max_width, G_TYPE_UINT, OUT_max_height, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_max_size_reply) (DBusGProxy *proxy, guint OUT_max_width, guint OUT_max_height, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_max_size_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_max_width;
  guint OUT_max_height;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_max_width, G_TYPE_UINT, &OUT_max_height, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_max_size_reply)data->cb) (proxy, OUT_max_width, OUT_max_height, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_max_size_async (DBusGProxy *proxy, com_eitv_lots_player_get_max_size_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_max_size", com_eitv_lots_player_get_max_size_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_set_pos (DBusGProxy *proxy, const guint IN_pos_x, const guint IN_pos_y, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_pos", error, G_TYPE_UINT, IN_pos_x, G_TYPE_UINT, IN_pos_y, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_set_pos_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_set_pos_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_set_pos_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_set_pos_async (DBusGProxy *proxy, const guint IN_pos_x, const guint IN_pos_y, com_eitv_lots_player_set_pos_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_pos", com_eitv_lots_player_set_pos_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pos_x, G_TYPE_UINT, IN_pos_y, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_pos (DBusGProxy *proxy, guint* OUT_pos_x, guint* OUT_pos_y, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_pos", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_pos_x, G_TYPE_UINT, OUT_pos_y, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_pos_reply) (DBusGProxy *proxy, guint OUT_pos_x, guint OUT_pos_y, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_pos_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_pos_x;
  guint OUT_pos_y;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_pos_x, G_TYPE_UINT, &OUT_pos_y, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_pos_reply)data->cb) (proxy, OUT_pos_x, OUT_pos_y, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_pos_async (DBusGProxy *proxy, com_eitv_lots_player_get_pos_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_pos", com_eitv_lots_player_get_pos_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_video_pid (DBusGProxy *proxy, guint* OUT_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_video_pid", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_pid, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_video_pid_reply) (DBusGProxy *proxy, guint OUT_pid, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_video_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_pid;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_pid, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_video_pid_reply)data->cb) (proxy, OUT_pid, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_video_pid_async (DBusGProxy *proxy, com_eitv_lots_player_get_video_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_video_pid", com_eitv_lots_player_get_video_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_set_video_pid (DBusGProxy *proxy, const guint IN_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_video_pid", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_set_video_pid_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_set_video_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_set_video_pid_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_set_video_pid_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_player_set_video_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_video_pid", com_eitv_lots_player_set_video_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_audio_pid (DBusGProxy *proxy, guint* OUT_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_audio_pid", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_pid, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_audio_pid_reply) (DBusGProxy *proxy, guint OUT_pid, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_audio_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_pid;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_pid, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_audio_pid_reply)data->cb) (proxy, OUT_pid, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_audio_pid_async (DBusGProxy *proxy, com_eitv_lots_player_get_audio_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_audio_pid", com_eitv_lots_player_get_audio_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_set_audio_pid (DBusGProxy *proxy, const guint IN_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_audio_pid", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_set_audio_pid_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_set_audio_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_set_audio_pid_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_set_audio_pid_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_player_set_audio_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_audio_pid", com_eitv_lots_player_set_audio_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_get_pcr_pid (DBusGProxy *proxy, guint* OUT_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_pcr_pid", error, G_TYPE_INVALID, G_TYPE_UINT, OUT_pid, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_get_pcr_pid_reply) (DBusGProxy *proxy, guint OUT_pid, GError *error, gpointer userdata);

static void
com_eitv_lots_player_get_pcr_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_pid;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_pid, G_TYPE_INVALID);
  (*(com_eitv_lots_player_get_pcr_pid_reply)data->cb) (proxy, OUT_pid, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_get_pcr_pid_async (DBusGProxy *proxy, com_eitv_lots_player_get_pcr_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_pcr_pid", com_eitv_lots_player_get_pcr_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_player_set_pcr_pid (DBusGProxy *proxy, const guint IN_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_pcr_pid", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_player_set_pcr_pid_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_player_set_pcr_pid_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_player_set_pcr_pid_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_player_set_pcr_pid_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_player_set_pcr_pid_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_pcr_pid", com_eitv_lots_player_set_pcr_pid_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_player */

#ifndef DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_demuxer
#define DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_demuxer

static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_demuxer_add_watch (DBusGProxy *proxy, const guint IN_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "add_watch", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_demuxer_add_watch_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_demuxer_add_watch_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_demuxer_add_watch_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_demuxer_add_watch_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_demuxer_add_watch_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "add_watch", com_eitv_lots_demuxer_add_watch_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_demuxer_del_watch (DBusGProxy *proxy, const guint IN_pid, GError **error)

{
  return dbus_g_proxy_call (proxy, "del_watch", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_demuxer_del_watch_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_demuxer_del_watch_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_demuxer_del_watch_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_demuxer_del_watch_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_demuxer_del_watch_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "del_watch", com_eitv_lots_demuxer_del_watch_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_demuxer_count_watch (DBusGProxy *proxy, const guint IN_pid, guint* OUT_count, GError **error)

{
  return dbus_g_proxy_call (proxy, "count_watch", error, G_TYPE_UINT, IN_pid, G_TYPE_INVALID, G_TYPE_UINT, OUT_count, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_demuxer_count_watch_reply) (DBusGProxy *proxy, guint OUT_count, GError *error, gpointer userdata);

static void
com_eitv_lots_demuxer_count_watch_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  guint OUT_count;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT, &OUT_count, G_TYPE_INVALID);
  (*(com_eitv_lots_demuxer_count_watch_reply)data->cb) (proxy, OUT_count, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_demuxer_count_watch_async (DBusGProxy *proxy, const guint IN_pid, com_eitv_lots_demuxer_count_watch_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "count_watch", com_eitv_lots_demuxer_count_watch_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT, IN_pid, G_TYPE_INVALID);
}
#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_demuxer */

#ifndef DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_source
#define DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_source

static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_source_set_uri (DBusGProxy *proxy, const char * IN_uri, GError **error)

{
  return dbus_g_proxy_call (proxy, "set_uri", error, G_TYPE_STRING, IN_uri, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_source_set_uri_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
com_eitv_lots_source_set_uri_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(com_eitv_lots_source_set_uri_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_source_set_uri_async (DBusGProxy *proxy, const char * IN_uri, com_eitv_lots_source_set_uri_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "set_uri", com_eitv_lots_source_set_uri_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_uri, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
com_eitv_lots_source_get_uri (DBusGProxy *proxy, char ** OUT_uri, GError **error)

{
  return dbus_g_proxy_call (proxy, "get_uri", error, G_TYPE_INVALID, G_TYPE_STRING, OUT_uri, G_TYPE_INVALID);
}

typedef void (*com_eitv_lots_source_get_uri_reply) (DBusGProxy *proxy, char * OUT_uri, GError *error, gpointer userdata);

static void
com_eitv_lots_source_get_uri_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  char * OUT_uri;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_uri, G_TYPE_INVALID);
  (*(com_eitv_lots_source_get_uri_reply)data->cb) (proxy, OUT_uri, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
com_eitv_lots_source_get_uri_async (DBusGProxy *proxy, com_eitv_lots_source_get_uri_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "get_uri", com_eitv_lots_source_get_uri_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_com_eitv_lots_source */

G_END_DECLS
